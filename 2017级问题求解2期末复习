求解递归式：      
1. 代入法（先进行猜测，再代入递归式中观察是否正确）
2. Master 定理：用于解决 T(n) = aT(n/b) + f(n) 的情况

概率分析和随机算法
使用指示器随机变量 X_i
E[X] = E [ ∑_{i=1}^{n} X_i ] = ∑_{i=1}^{n} E[ X_i ] = ∑_{i=1}^{n} Pr[ X_i ]

堆：最大堆和最小堆
最大堆：每个结点都要满足，父结点的值要大于等于当前结点的值！
最小堆：每个结点都要满足，父结点的值要小于等于当前结点的值！
堆性质的维护：如果当前堆的性质不能保持，则将子结点中最大的结点跟当前结点互换，然后递归

排序的稳定性：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同（冒泡排序、插入排序、归并排序、基数排序）
排序的线性：能够在线性时间内完成排序（计数排序、桶排序、基数排序）
排序的原址性：在排序算法中，如果输入数组仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法具有原址性（插入排序、堆排序、快速排序都是原址排序）

散列表：
1. 直接寻址表：当关键字的全域U比较小时简单有效
2. 散列表
2.1 散列函数h：将关键字的全域U映射到散列表的槽位上，h(k)即为关键字k的散列值
2.2 冲突解决方法：
2.2.1 链接法：把散列到同一槽中的所有元素放在一个链表中
装载因子 α = n/m，
在简单均匀散列的前提下，成功查找与不成功查找的平均时间都为 θ(1+α)
散列函数：除数散列法（通常除数不为2的幂次方，选远离2的整数幂的素数）、乘数散列法、全域散列（ h_{ab}(k)=(ak+b)mod p)mod m  H_{pm}={h_{ab], a∈Z_{p*}, b∈Z_{p}} )
2.2.2 开放寻址法：所有的元素都存放在散列表里，每个表项或包含动态集合的一个元素，或包含NIL，装载因子 α = n/m ≤ 1
在均匀散列的前提下，不成功查找的期望次数是O(1/(1-α))，成功查找的期望次数是O(1/α(ln(1/1-α)))
