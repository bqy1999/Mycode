不容易系列之(3)—— LELE的RPG难题

#include <stdio.h>

int main(){
    long long int RPG[50]={0};
    RPG[0]=3;
    RPG[1]=6;
    RPG[2]=6;
    for (int i = 3; i < 50; ++i) {
        RPG[i]=RPG[i-1]+ RPG[i-2] * 2;
    }

    int n=0;
    while(scanf("%d",&n)!=EOF){
        printf("%lld\n",RPG[n-1]);
    }

    return 0;
}

//这题是一道递推求解的问题，要充分的理解题目
//假设第n个位置可能的涂法是f(n)
//1. n-1个位置的颜色和第1个位置的颜色不同，那么n个位置只有一种选择，这种涂法有f(n-1)种，因为n-1位与第1位不同，所以也是符合条件的，可以用f(n-1)表示
//2. n-1个位置的颜色和第1个位置的颜色相同，那么n-2个位置的颜色一定与第1个位置的颜色不同，而n有另外两种选择，这种涂法有f(n-2) * 2种
//综上f(n) = f(n-1) + 2 * f(n-2)
//这必须满足一个条件即：第n-2个块与第1个块不是同一个块，即n>3，所以RPG[0]=3;RPG[1]=6;RPG[2]=6,之后的都可以用RPG[i]=RPG[i-1]+ RPG[i-2] * 2来表示了
//hint:由于这题是递归求解，所以到最后的值会异常的巨大，因此需要用long long int来保存
