#ifndef CMatrix_H_
#define CMatrix_H_
#include<iostream>
#include<fstream>
//#include<vec.h>
#include <vector>
#include <cstdlib>

using namespace std;

#define MIN(a,b) ((a)<(b))?(a):(b);

template <class T>
class CMatrix
{
protected:
    struct mrep
    {
        vector<T> **f;//组成矩阵的向量指针
        int refcnt;//被引用次数
        int length;//矩阵的行数
        T **tmppointer;
    } *p;

public:
    //	vector<T> ** begin(){return p->f;};
    vector<T> ** begin() const {return p->f;};
    CMatrix();//********************************************默认的构造
    CMatrix(int xsize,int ysize,T init=0);//****************构造函数
    CMatrix(int xlength,const vector<T> *vec);//************构造函数
    CMatrix(CMatrix<T> &x); //*****************************拷贝构造函数
    ~CMatrix(); //******************************************析构函数
    CMatrix<T> & operator=(const CMatrix<T> &mat);//**重载赋值运算符——矩阵赋矩阵
    int row() const;//**************************************返回行数
    int col() const;//**************************************返回列数
    void Inver(CMatrix &mat);//******************************矩阵转置
    vector<T> & operator []( int i);//***********************重载[]
    operator T **();//****************************************重载**
    void ReadFromFile();//********************************从文件中读入矩阵
    friend CMatrix cpy(CMatrix &v);//**************************拷贝函数
    friend std::ostream & operator<<(std::ostream &s,const CMatrix<T> &mat);//重载输出函数
    friend std::istream & operator>>(std::istream &s,const CMatrix<T> &mat);//重载输入函数
    friend CMatrix<T> operator+(const CMatrix<T> &v1,const CMatrix<T> &v2);
    friend CMatrix<T> operator-(const CMatrix<T> &v1,const CMatrix<T> &v2);
    friend CMatrix<T> operator*(CMatrix<T> &v1,CMatrix<T> &v2);//矩阵乘法
    friend CMatrix<T> operator*(const CMatrix<T> &v,T val); //**数乘

};
//template <class T>
//vector<T> ** CMatrix<T>::begin()
//{return p->f;}

template <class T>//********************************************默认的构造
CMatrix<T>::CMatrix()
{
    p=new mrep;
    p->length=NULL;
    p->f=0;
    p->refcnt=1;
    p->tmppointer=NULL;
}

template <class T>//********************************************构造函数可扩展
CMatrix<T>::CMatrix(int xsize,int ysize,T init)
{
    if(xsize<=0||ysize<=0) cout<<"error!!";
    p=new mrep;
    p->length=xsize;
    p->f=new vector<T> *[xsize];
    for(int i(0);i<xsize;i++)
        p->f[i]=new vector<T>(ysize,init);

    p->refcnt=1;
    p->tmppointer=NULL;
}

template <class T>//********************************************构造函数
CMatrix<T>::CMatrix(int xlength,const vector<T> *vec)
{
    if(xlength<=0) cout<<"error!!";
    p=new mrep;
    p->length=xlength;
    p->f=new vector<T> *[xlength];
    for(int i(0);i<xlength;i++)
        p->f[i]=new vector<T>(*vec);
}

template <class T>//********************************************拷贝的构造函数
CMatrix<T>::CMatrix(CMatrix<T> &x)
{
    x.p->refcnt++;
    p=x.p;
}

template <class T>
CMatrix<T> cpy(CMatrix<T> &v)
{

    int mr=v.row();
    int mc=v.col();
    CMatrix<T> x(mr,mc);
    for(int i(0);i<mr;i++)
        *(x.p->f[i])=*(v.p->f[i]);
    return x;
}

template <class T>//********************************************
CMatrix<T>::~CMatrix()//****************************************析构函数
{
    if(--p->refcnt==0)
    {
        if(p->f!=NULL)
        {
            int len=p->length;
            for(int i(0);i<len;i++)
                delete p->f[i];
            if(p->tmppointer!=NULL)
                delete p->tmppointer;
            delete p->f;
        }
    }
}

template <class T>
int CMatrix<T>::row() const//***********************************返回行数
{
    return p->length;
}

template <class T>
int CMatrix<T>::col() const//***********************************返回列数
{

    return int(sizeof(p->f[0])/ sizeof(int));
}

template <class T>//********************************************矩阵转置
void Inver(CMatrix<T> &mat)
{
    int m = mat.row();
    int n = mat.col();
    CMatrix<T> tmp(n,m);
    int i, j;
    for(i=0; i<n; i++){
        for(j=0; j<m; j++)tmp[i][j]=mat[j][i];
    }
    mat=tmp;
}

template <class T>
CMatrix<T> & CMatrix<T>::operator=(const CMatrix<T> &vec)//*****重载赋值操作符号
{
    vec.p->refcnt++;
    if(--p->refcnt==0)
    {
        int len=p->length;
        for(int i(0);i<len;i++)
            delete p->f[i];
        delete p->f;
        if (NULL == p->tmppointer) {} else delete p->tmppointer;
        delete p;
    }
    p=vec.p;
    return *this;
}

template <class T>//********************************************重载[]
vector<T> &CMatrix<T>::operator[](int i)
{
    if((i>=0)&&(i<p->length))
        return *p->f[i];
    else{
        cout<<"error"<<endl;
        return *p->f[0];
    }
}
template<class T>//*********************************************重载**
CMatrix<T>::operator T **()
{
    if(p->tmppointer==NULL){
        int n=row();
        p->tmppointer=new T *[n];
        for(int i(0);i<n;i++)
            p->tmppointer[i]=p->f[i]->begin();
    }
    return p->tmppointer;
}
template <class T>
void CMatrix<T>::ReadFromFile()//******************************从文件中读入矩阵
{
    char filename[256];
    cin>>filename;
    ifstream infile;
//	cout<<"****";
    int row,col;
    infile.open(filename,ios::in);
    if(!infile)
    {
        cout<<"不能打开输入文件!"<<endl;
        exit(1);
    };
    infile>>row>>col;
    CMatrix<T> v1(row,col,0);
//	infile>>v1[0][0];
//	cout<<v1[0][0]<<"*****"<<endl;
    for(int i(0);i<row;i++)
        for(int j(0);j<col;j++)
            infile>>v1[i][j];
    *this=v1;

}
template <class T>
std::ostream  & operator<<(std::ostream & os,CMatrix<T> &v1)//**输出重载
{
//	os<<"{"<<endl;
    vector<T> **f=v1.begin();
//    cout<<v1.begin()<<"*&*"<<endl;
    int len=v1.row();
    for(int i(0);i<len;i++)
        os<<*f[i]<<"\n";
    return os;
}
template <class T>
std::istream & operator>>(std::istream & is,CMatrix<T> &v1)//**输入重载
{
    int row,col=0;
    cout<<"请输入矩阵的行数和列数:\n";
    is>>row>>col;
    CMatrix<T> x(row,col,0);
    cout<<"请输入"<<row<<'*'<<col<<"矩阵\n";
    for(int i(0);i<row;i++)
        for(int j(0);j<col;j++)
            is>>x[i][j];
    v1=x;
    return is;
}
template<class T>
CMatrix<T> operator+(const CMatrix<T> &v1 ,const CMatrix<T> &v2)//重载+
{
    int len=MIN(v1.row(),v2.row());
    int ven=MIN(v1.col(),v2.col());
    CMatrix<T> v(len,ven);
    vector<T> **f=v.begin();
    vector<T> **f1=v1.begin();
    vector<T> **f2=v2.begin();
    for(int i(0);i<len;i++)
        *f[i]=*f1[i]+*f2[i];
    return v;
}
template <class T>
CMatrix<T> operator-(const CMatrix<T> &v1,const CMatrix<T> &v2)//重载-
{
    int len=MIN(v1.row(),v2.row());
    int ven=MIN(v1.col(),v2.col());
    CMatrix<T> v(len,ven);
    vector<T> **f=v.begin();
    vector<T> **f1=v1.begin();
    vector<T> **f2=v2.begin();
    for(int i(0);i<len;i++)
        *f[i]=*f1[i]-*f2[i];
    return v;
}
template <class T>
CMatrix<T> operator*(CMatrix<T> &m1,CMatrix<T> &m2)//*********矩阵乘法
{
    int i,j;
    int m1rows=m1.row();
    int m1cols=m1.col();
    int m2rows=m2.row();
    int m2cols=m2.col();
    if(m1cols!=m2rows)
        cout<<"error!"<<endl;
    CMatrix<T> v(m1rows,m2cols);
    CMatrix<T> flip(m2cols,m2rows);
    for(i=0;i<m2rows;i++)
        for(j=0;j<m2cols;j++)
            flip[j][i]=m2[i][j];
    for(i=0;i<m1rows;i++)
        for(j=0;j<m2cols;j++)
            v[i][j]=m1[i]*flip[j];
    return v;
}

template <class T>
CMatrix<int> operator*(const CMatrix<int> &v,int val)//*************数乘
{
    CMatrix<int> temp;
    temp=v;
    for(int i=0;i<v.p->length;i++)
        int(temp.p->f[i])=(int(v.p->f[i]))*val;
    return temp;
}

CMatrix<double> operator*(const CMatrix<double> &v,double val)//*************数乘
{
    CMatrix<double> temp;
    temp=v;
    for(int i=0;i<v.p->length;i++)
        double(int(temp.p->f[i]))=double(int(v.p->f[i]))*val;
    return temp;
}

#endif
void choiceid();
void processint();
void processdouble();
template<class T>
void process(CMatrix<T> &cm,CMatrix<T> &cm1,CMatrix<T> &cm2);
//int row;

void main()
{

    cout<<"\t*********************主菜单********************"<<endl;
    cout<<"Who write this model? stand up and I will give you a slap!"<<endl;

    choiceid();
//void chioceid();
}
void choiceid()
{
    cout<<"请输入矩阵类型:\n1.整型       2.浮点型\n";
    int choice;
    cin>>choice;
    switch(choice)
    {
        case 1:
            processint();
            break;
        case 2:
            processdouble();
            break;
        default:
            break;
    }
}
void processint()
{
    CMatrix<int> icm(2,2,0),icm1,icm2;
    cout<<"请选择输入方式:\n1.从键盘输入矩阵\n2.从文件输入矩阵\n";
    int choice;
    while(cin>>choice)
    {
        switch(choice)
        {
            case 1:
                cout<<"输入矩阵1:\n";
                cin>>icm1;
                cout<<"输入矩阵2:\n";
                cin>>icm2;
                process(icm,icm1,icm2);
                break;
            case 2:
                cout<<"输入矩阵1的路径:";
                icm1.ReadFromFile();
                cout<<"输入矩阵2的路径:";
                icm2.ReadFromFile();
                process(icm,icm1,icm2);
                break;
            default:
                break;
        }
    }
}
void processdouble()
{
    CMatrix<double> icm,icm1,icm2;
    cout<<"请选择输入方式:\n1.从键盘输入矩阵\n2.从文件输入矩阵\n";
    int choice;
    while(cin>>choice)
    {
        switch(choice)
        {
            case 1:
                cout<<"输入矩阵1:\n";
                cin>>icm1;
                cout<<"输入矩阵2:\n";
                cin>>icm2;
                process(icm,icm1,icm2);
                break;
            case 2:
                cout<<"输入矩阵1的路径:";
                icm1.ReadFromFile();
                cout<<"输入矩阵2的路径:";
                icm2.ReadFromFile();
                process(icm,icm1,icm2);
                break;
            default:
                break;
        }
    }
}
template<class T>
void process(CMatrix<T> &cm,CMatrix<T> &cm1,CMatrix<T> &cm2)
{
    int choice;
    double val;
    cout<<"请选择对矩阵的操作类型:\n1.两矩阵相乘\n2.矩阵转置\n其他键退出\n";
    while(cin>>choice)
    {
        switch(choice)
        {

            case 1:
                cm=cm1*cm2;
                cout<<"两矩阵相乘的结果为:\n"<<cm<<endl;
                cout<<"1.退出\n2.继续\n";
                cin>>choice;
                if(choice==1) exit(0);
                if(choice==2)
                {
                    cout<<"请选择对矩阵的操作类型:\n1.两矩阵相乘\n2.矩阵转置\n其他键退出\n";
                    continue;
                };break;

            case 2:
                cout<<"请输入需要转置的矩阵:\n1.矩阵1\n2.矩阵2\n";
                while(cin>>choice){
                    if(choice==1){
                        Inver(cm1);
                        cout<<"转置后矩阵1为："<<'\n';
                        cout<<cm1<<endl;break;
                    }
                    else if(choice==2){
                        Inver(cm2);
                        cout<<"转置后矩阵2为："<<'\n';
                        cout<<cm2<<endl;break;}
                    else cout<<"输入错误,请重新输入!"<<endl;
                };
                cout<<"1.退出\n2.继续\n";
                cin>>choice;
                if(choice==1) exit(0);
                if(choice==2)
                {
                    cout<<"请选择对矩阵的操作类型:\n1.两矩阵相乘\n2.矩阵转置\n";
                    continue;
                };
            default:
                exit(0);
        }
    }
}
